/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.group20.docker.validation;

import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import uk.ac.kcl.inf.group20.docker.docker.Model
import uk.ac.kcl.inf.group20.docker.docker.DockerPackage
import java.util.List
import uk.ac.kcl.inf.group20.docker.docker.Statements
import uk.ac.kcl.inf.group20.docker.docker.KillStatement
import uk.ac.kcl.inf.group20.docker.docker.ContainerNameDeclaration
import uk.ac.kcl.inf.group20.docker.docker.RunCreateStatement
import uk.ac.kcl.inf.group20.docker.docker.StartStatement
import uk.ac.kcl.inf.group20.docker.docker.StopStatement
import uk.ac.kcl.inf.group20.docker.docker.PauseStatement
import uk.ac.kcl.inf.group20.docker.docker.RestartStatement
import uk.ac.kcl.inf.group20.docker.docker.RemoveStatement
import uk.ac.kcl.inf.group20.docker.docker.UnpauseStatement
import uk.ac.kcl.inf.group20.docker.docker.ExecStatement
import uk.ac.kcl.inf.group20.docker.docker.PsStatement
import uk.ac.kcl.inf.group20.docker.docker.InspectStatement
import uk.ac.kcl.inf.group20.docker.docker.AttachStatement
import uk.ac.kcl.inf.group20.docker.docker.EventStatement
import uk.ac.kcl.inf.group20.docker.docker.LogsStatement
import uk.ac.kcl.inf.group20.docker.docker.WaitStatement
import uk.ac.kcl.inf.group20.docker.docker.ExportStatement
import uk.ac.kcl.inf.group20.docker.docker.PortStatement
import uk.ac.kcl.inf.group20.docker.docker.CommitStatement
import uk.ac.kcl.inf.group20.docker.docker.CpStatement
import uk.ac.kcl.inf.group20.docker.docker.DiffStatement
import uk.ac.kcl.inf.group20.docker.docker.ImageStatement
import uk.ac.kcl.inf.group20.docker.docker.RemoveImageStatement
import uk.ac.kcl.inf.group20.docker.docker.RunOption
import uk.ac.kcl.inf.group20.docker.docker.LogOptions

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class DockerValidator extends AbstractDockerValidator {
	
	public static val INVALID_KILLED_CONTAINER = 'uk.ac.kcl.inf.group20.docker.INVALID_KILLED_CONTAINER'
	public static val INVALID_STOPPED_CONTAINER = 'uk.ac.kcl.inf.group20.docker.INVALID_STOPPED_CONTAINER'
	public static val INVALID_UNSTOPPED_CONTAINER = 'uk.ac.kcl.inf.group20.docker.INVALID_UNSTOPPED_CONTAINER'
	public static val INVALID_PAUSED_CONTAINER = 'uk.ac.kcl.inf.group20.docker.INVALID_PAUSED_CONTAINER'
	public static val INVALID_UNPAUSED_CONTAINER = 'uk.ac.kcl.inf.group20.docker.INVALID_UNPAUSED_CONTAINER'
	public static val INVALID_PRIVATE_PORT = 'uk.ac.kcl.inf.group20.docker.INVALID_PRIVATE_PORT'
	public static val INVALID_SINCE_TIME = 'uk.ac.kcl.inf.group20.docker.INVALID_SINCE_TIME'

	var List<String> killedContainer = newArrayList
	var List<String> stoppedContainer = newArrayList
	var List<String> pausedContainer = newArrayList
	
	
		@Check(NORMAL)
	def clearList(Model model){
		killedContainer.clear()
		stoppedContainer.clear()
		pausedContainer.clear()
	}
	
	@Check(NORMAL)
	def setKilledList(KillStatement stmt){
		killedContainer.add(stmt.containerName.name)
	}
	
	@Check(NORMAL)
	def setStoppedList(StopStatement stmt){
		stoppedContainer.add(stmt.containerName.name)
	}
	
	@Check(NORMAL)
	def setPausedContainer(PauseStatement stmt){
		pausedContainer.add(stmt.containerName.name)
	}
	
	@Check(NORMAL)
  	def CheckRunCreateStatementContainer(RunCreateStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if (!stmt.runOptions.empty){
  				for(var j = 0; j < stmt.runOptions.size; j++){
  					if (stmt.runOptions.get(j).condition.equals("name")){
   						if (killedContainer.get(i).equals(stmt.runOptions.get(j).containerName.name)){
	   						warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    				DockerPackage.Literals.RUN_CREATE_STATEMENT__RUN_OPTIONS, j, INVALID_KILLED_CONTAINER)
		    			}
		    		}
  				}
  			}
  		}
	}
		
	@Check(NORMAL)
  	def CheckStartStatementContainer(StartStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.START_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
		      
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckStopStatementContainer(StopStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
  		
  		for (var i = 0; i < stoppedContainer.size; i++){
  			if(stoppedContainer.get(i).equals(stmt.containerName.name) && stoppedContainer.indexOf(stoppedContainer.get(i)) != i){
   				warning('Container "' + stoppedContainer.get(i) + '" has been stopped', stmt,
		    	DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME, INVALID_STOPPED_CONTAINER)
  			}
  		}
  	}
	
	@Check(NORMAL)
  	def CheckRestartStatementContainer(RestartStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		   		DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}		
  		}
  		
  		if(stoppedContainer.indexOf(stmt.containerName.name.toString) < 0){
   			warning('Container "' + stmt.containerName.name + '" has not been stopped', stmt,
		  	DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME, INVALID_UNSTOPPED_CONTAINER)
  		}
  		else {
  			stoppedContainer.remove(stoppedContainer.indexOf(stmt.containerName.name))
  		}
	}

	@Check(NORMAL)
	def CheckKillStatementContainer(KillStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name) && killedContainer.indexOf(killedContainer.get(i)) != i){
   				warning('Container "' + killedContainer.get(i).toString + '" has been killed', stmt,
		    	DockerPackage.Literals.KILL_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
  	}
	
	@Check(NORMAL)
  	def CheckRemoveStatementContainer(RemoveStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.REMOVE_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckPauseStatementContainer(PauseStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
  		
  		for (var i = 0; i < pausedContainer.size; i++){
  			if(pausedContainer.get(i).equals(stmt.containerName.name) && pausedContainer.indexOf(pausedContainer.get(i)) != i){
   				warning('Container "' + pausedContainer.get(i) + '" has been paused', stmt,
		    	DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME, INVALID_PAUSED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckUnpauseStatementContainer(UnpauseStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}		
  		}
  		
  		if(pausedContainer.indexOf(stmt.containerName.name.toString) < 0){
   			warning('Container "' + stmt.containerName.name + '" has not been paused', stmt,
		   	DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME, INVALID_UNPAUSED_CONTAINER)
  		}
  		else {
  			pausedContainer.remove(pausedContainer.indexOf(stmt.containerName.name))
  		}
	}

	@Check(NORMAL)
  	def CheckExecStatementContainer(ExecStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.EXEC_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	

	@Check(NORMAL)
  	def CheckAttachStatementContainer(AttachStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.ATTACH_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}

	@Check(NORMAL)
  	def CheckLogsStatementContainer(LogsStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.LOGS_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckWaitStatementContainer(WaitStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.WAIT_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckExportStatementContainer(ExportStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.EXPORT_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckPortStatementContainer(PortStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.PORT_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckCommitStatementContainer(CommitStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.COMMIT_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckCpStatementContainer(CpStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.source.option2.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.CP_STATEMENT__SOURCE, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
  	def CheckDiffStatementContainer(DiffStatement stmt){
  		for (var i = 0; i < killedContainer.size; i++){
  			if(killedContainer.get(i).equals(stmt.containerName.name)){
   				warning('Container "' + killedContainer.get(i) + '" has been killed', stmt,
		    	DockerPackage.Literals.DIFF_STATEMENT__CONTAINER_NAME, INVALID_KILLED_CONTAINER)
  			}
  		}
	}
	
	@Check(NORMAL)
	def checkPortFormatStatementPort(PortStatement stmt){
		var port = stmt.private_port.split("[.]")
		if(port.size != 4 || port.get(3).split("\\:").size != 3){
			warning('The port format must be xx.xx.xx.xx:xx'.toString, stmt,
		    		DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT, INVALID_PRIVATE_PORT)
		}
	}
	
	
	@Check(NORMAL)
	def checkPortNumberStatementPort(PortStatement stmt){
		var port = stmt.private_port.split("[.]")
		for(var i = 0; i < port.size; i++){
			for(var j = 0; j < port.get(i).length; j++){
				
				var c = port.get(i).charAt(j).toString
				var digitals = "0 1 2 3 4 5 6 7 8 9 :".split(" ")
				var judge = false 
				
				for(var k = 0; k < digitals.size; k++){
					if(c.equals(digitals.get(k))){
						judge = true
					}
				}
				
				if(judge == false){
					warning('The port should be number', stmt,
		    		DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT, INVALID_PRIVATE_PORT)
				}
			}
		}
	}
	
	@Check(NORMAL)
	def checkRunPortFormatStatementPort(RunOption stmt){
		var port = stmt.portName.split("[.]")
		if(port.size != 4 || port.get(3).split("\\:").size != 3){
		warning('The port format must be xx.xx.xx.xx:xx'.toString, stmt,
		   	DockerPackage.Literals.RUN_OPTION__PORT_NAME, INVALID_PRIVATE_PORT)
		}
	}
	
	
	@Check(NORMAL)
	def checkRunPortNumberStatementPort(RunOption stmt){
		var port = stmt.portName.split("[.]")
		for(var i = 0; i < port.size; i++){
			for(var j = 0; j < port.get(i).length; j++){
				
				var c = port.get(i).charAt(j).toString
				var digitals = "0 1 2 3 4 5 6 7 8 9 :".split(" ")
				var judge = false 
				
				for(var k = 0; k < digitals.size; k++){
					if(c.equals(digitals.get(k))){
						judge = true
					}
				}
				
				if(judge == false){
					warning('The port should be number', stmt,
		    		DockerPackage.Literals.RUN_OPTION__PORT_NAME, INVALID_PRIVATE_PORT)
				}
			}
		}
	}
	
	@Check(NORMAL)
	def checkLogStatementTimeFormat(LogOptions stmt){
		var logtime = stmt.time.split("-")
		if(logtime.size != 3){
		warning('The time format must be xx-xx-xx'.toString, stmt,
		   	DockerPackage.Literals.LOG_OPTIONS__TIME, INVALID_SINCE_TIME)
		}
	}
	
	
	@Check(NORMAL)
	def checkLogStatementTimeNumberFormat1(LogOptions stmt){
		var logtime = stmt.time.split("-")
		for(var i = 0; i < logtime.size; i++){
			for(var j = 0; j < logtime.get(i).length; j++){
				
				var c = logtime.get(i).charAt(j).toString
				var digitals = "0 1 2 3 4 5 6 7 8 9".split(" ")
				var judge = false 
				
				for(var k = 0; k < digitals.size; k++){
					if(c.equals(digitals.get(k))){
						judge = true
					}
				}
				
				if(judge == false){
					warning('The time should be number', stmt,
		    		DockerPackage.Literals.LOG_OPTIONS__TIME, INVALID_SINCE_TIME)
				}
			}
		}
	}
	
	@Check(NORMAL)
	def checkLogStatementTimeNumberFormat2(LogOptions stmt){
		var logtime = stmt.time.split("-")

		var year_String_time = logtime.get(0)
		var year_int_time = Integer.parseInt(year_String_time);
		if(year_int_time < 2019 && year_int_time > 2022){
			warning('The time must be greater than 2019-01-01 and less than 2022', stmt,
		   		DockerPackage.Literals.LOG_OPTIONS__TIME, INVALID_SINCE_TIME)
		}
		
		var month_String_time = logtime.get(1)
		var month_int_time = Integer.parseInt(month_String_time);
		if(month_int_time > 12 || month_int_time < 1){
			warning('The time must be greater than 2019-01-01 and less than 2022', stmt,
		   		DockerPackage.Literals.LOG_OPTIONS__TIME, INVALID_SINCE_TIME)
		}
		
		var day_String_time = logtime.get(2)
		var day_int_time = Integer.parseInt(day_String_time);
		if(day_int_time > 31 || day_int_time < 1){
			warning('The time must be greater than 2019-01-01 and less than 2022', stmt,
		   		DockerPackage.Literals.LOG_OPTIONS__TIME, INVALID_SINCE_TIME)
		}
	}
}