/**
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.group20.docker.validation;

import java.util.List;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import uk.ac.kcl.inf.group20.docker.docker.AttachStatement;
import uk.ac.kcl.inf.group20.docker.docker.CommitStatement;
import uk.ac.kcl.inf.group20.docker.docker.CpStatement;
import uk.ac.kcl.inf.group20.docker.docker.DiffStatement;
import uk.ac.kcl.inf.group20.docker.docker.DockerPackage;
import uk.ac.kcl.inf.group20.docker.docker.ExecStatement;
import uk.ac.kcl.inf.group20.docker.docker.ExportStatement;
import uk.ac.kcl.inf.group20.docker.docker.KillStatement;
import uk.ac.kcl.inf.group20.docker.docker.LogOptions;
import uk.ac.kcl.inf.group20.docker.docker.LogsStatement;
import uk.ac.kcl.inf.group20.docker.docker.Model;
import uk.ac.kcl.inf.group20.docker.docker.PauseStatement;
import uk.ac.kcl.inf.group20.docker.docker.PortStatement;
import uk.ac.kcl.inf.group20.docker.docker.RemoveStatement;
import uk.ac.kcl.inf.group20.docker.docker.RestartStatement;
import uk.ac.kcl.inf.group20.docker.docker.RunCreateStatement;
import uk.ac.kcl.inf.group20.docker.docker.RunOption;
import uk.ac.kcl.inf.group20.docker.docker.StartStatement;
import uk.ac.kcl.inf.group20.docker.docker.StopStatement;
import uk.ac.kcl.inf.group20.docker.docker.UnpauseStatement;
import uk.ac.kcl.inf.group20.docker.docker.WaitStatement;
import uk.ac.kcl.inf.group20.docker.validation.AbstractDockerValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DockerValidator extends AbstractDockerValidator {
  public static final String INVALID_KILLED_CONTAINER = "uk.ac.kcl.inf.group20.docker.INVALID_KILLED_CONTAINER";
  
  public static final String INVALID_STOPPED_CONTAINER = "uk.ac.kcl.inf.group20.docker.INVALID_STOPPED_CONTAINER";
  
  public static final String INVALID_UNSTOPPED_CONTAINER = "uk.ac.kcl.inf.group20.docker.INVALID_UNSTOPPED_CONTAINER";
  
  public static final String INVALID_PAUSED_CONTAINER = "uk.ac.kcl.inf.group20.docker.INVALID_PAUSED_CONTAINER";
  
  public static final String INVALID_UNPAUSED_CONTAINER = "uk.ac.kcl.inf.group20.docker.INVALID_UNPAUSED_CONTAINER";
  
  public static final String INVALID_PRIVATE_PORT = "uk.ac.kcl.inf.group20.docker.INVALID_PRIVATE_PORT";
  
  public static final String INVALID_SINCE_TIME = "uk.ac.kcl.inf.group20.docker.INVALID_SINCE_TIME";
  
  private List<String> killedContainer = CollectionLiterals.<String>newArrayList();
  
  private List<String> stoppedContainer = CollectionLiterals.<String>newArrayList();
  
  private List<String> pausedContainer = CollectionLiterals.<String>newArrayList();
  
  @Check(CheckType.NORMAL)
  public void clearList(final Model model) {
    this.killedContainer.clear();
    this.stoppedContainer.clear();
    this.pausedContainer.clear();
  }
  
  @Check(CheckType.NORMAL)
  public boolean setKilledList(final KillStatement stmt) {
    return this.killedContainer.add(stmt.getContainerName().getName());
  }
  
  @Check(CheckType.NORMAL)
  public boolean setStoppedList(final StopStatement stmt) {
    return this.stoppedContainer.add(stmt.getContainerName().getName());
  }
  
  @Check(CheckType.NORMAL)
  public boolean setPausedContainer(final PauseStatement stmt) {
    return this.pausedContainer.add(stmt.getContainerName().getName());
  }
  
  @Check(CheckType.NORMAL)
  public void CheckRunCreateStatementContainer(final RunCreateStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _isEmpty = stmt.getRunOptions().isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        for (int j = 0; (j < stmt.getRunOptions().size()); j++) {
          boolean _equals = stmt.getRunOptions().get(j).getCondition().equals("name");
          if (_equals) {
            boolean _equals_1 = this.killedContainer.get(i).equals(stmt.getRunOptions().get(j).getContainerName().getName());
            if (_equals_1) {
              String _get = this.killedContainer.get(i);
              String _plus = ("Container \"" + _get);
              String _plus_1 = (_plus + "\" has been killed");
              this.warning(_plus_1, stmt, 
                DockerPackage.Literals.RUN_CREATE_STATEMENT__RUN_OPTIONS, j, DockerValidator.INVALID_KILLED_CONTAINER);
            }
          }
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckStartStatementContainer(final StartStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.START_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckStopStatementContainer(final StopStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
    for (int i = 0; (i < this.stoppedContainer.size()); i++) {
      if ((this.stoppedContainer.get(i).equals(stmt.getContainerName().getName()) && (this.stoppedContainer.indexOf(this.stoppedContainer.get(i)) != i))) {
        String _get = this.stoppedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been stopped");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_STOPPED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public String CheckRestartStatementContainer(final RestartStatement stmt) {
    String _xblockexpression = null;
    {
      for (int i = 0; (i < this.killedContainer.size()); i++) {
        boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
        if (_equals) {
          String _get = this.killedContainer.get(i);
          String _plus = ("Container \"" + _get);
          String _plus_1 = (_plus + "\" has been killed");
          this.warning(_plus_1, stmt, 
            DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
        }
      }
      String _xifexpression = null;
      int _indexOf = this.stoppedContainer.indexOf(stmt.getContainerName().getName().toString());
      boolean _lessThan = (_indexOf < 0);
      if (_lessThan) {
        String _name = stmt.getContainerName().getName();
        String _plus = ("Container \"" + _name);
        String _plus_1 = (_plus + "\" has not been stopped");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_UNSTOPPED_CONTAINER);
      } else {
        _xifexpression = this.stoppedContainer.remove(this.stoppedContainer.indexOf(stmt.getContainerName().getName()));
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check(CheckType.NORMAL)
  public void CheckKillStatementContainer(final KillStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      if ((this.killedContainer.get(i).equals(stmt.getContainerName().getName()) && (this.killedContainer.indexOf(this.killedContainer.get(i)) != i))) {
        String _string = this.killedContainer.get(i).toString();
        String _plus = ("Container \"" + _string);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.KILL_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckRemoveStatementContainer(final RemoveStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.REMOVE_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckPauseStatementContainer(final PauseStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
    for (int i = 0; (i < this.pausedContainer.size()); i++) {
      if ((this.pausedContainer.get(i).equals(stmt.getContainerName().getName()) && (this.pausedContainer.indexOf(this.pausedContainer.get(i)) != i))) {
        String _get = this.pausedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been paused");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_PAUSED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public String CheckUnpauseStatementContainer(final UnpauseStatement stmt) {
    String _xblockexpression = null;
    {
      for (int i = 0; (i < this.killedContainer.size()); i++) {
        boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
        if (_equals) {
          String _get = this.killedContainer.get(i);
          String _plus = ("Container \"" + _get);
          String _plus_1 = (_plus + "\" has been killed");
          this.warning(_plus_1, stmt, 
            DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
        }
      }
      String _xifexpression = null;
      int _indexOf = this.pausedContainer.indexOf(stmt.getContainerName().getName().toString());
      boolean _lessThan = (_indexOf < 0);
      if (_lessThan) {
        String _name = stmt.getContainerName().getName();
        String _plus = ("Container \"" + _name);
        String _plus_1 = (_plus + "\" has not been paused");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_UNPAUSED_CONTAINER);
      } else {
        _xifexpression = this.pausedContainer.remove(this.pausedContainer.indexOf(stmt.getContainerName().getName()));
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check(CheckType.NORMAL)
  public void CheckExecStatementContainer(final ExecStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.EXEC_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckAttachStatementContainer(final AttachStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.ATTACH_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckLogsStatementContainer(final LogsStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.LOGS_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckWaitStatementContainer(final WaitStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.WAIT_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckExportStatementContainer(final ExportStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.EXPORT_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckPortStatementContainer(final PortStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.PORT_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckCommitStatementContainer(final CommitStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.COMMIT_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckCpStatementContainer(final CpStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getSource().getOption2().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.CP_STATEMENT__SOURCE, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckDiffStatementContainer(final DiffStatement stmt) {
    for (int i = 0; (i < this.killedContainer.size()); i++) {
      boolean _equals = this.killedContainer.get(i).equals(stmt.getContainerName().getName());
      if (_equals) {
        String _get = this.killedContainer.get(i);
        String _plus = ("Container \"" + _get);
        String _plus_1 = (_plus + "\" has been killed");
        this.warning(_plus_1, stmt, 
          DockerPackage.Literals.DIFF_STATEMENT__CONTAINER_NAME, DockerValidator.INVALID_KILLED_CONTAINER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPortFormatStatementPort(final PortStatement stmt) {
    String[] port = stmt.getPrivate_port().split("[.]");
    if (((((List<String>)Conversions.doWrapArray(port)).size() != 4) || (((List<String>)Conversions.doWrapArray((port[3]).split("\\:"))).size() != 2))) {
      this.warning("The port format must be xx.xx.xx.xx:xx".toString(), stmt, 
        DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT, DockerValidator.INVALID_PRIVATE_PORT);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPortNumberStatementPort(final PortStatement stmt) {
    String[] port = stmt.getPrivate_port().split("[.]");
    for (int i = 0; (i < ((List<String>)Conversions.doWrapArray(port)).size()); i++) {
      for (int j = 0; (j < (port[i]).length()); j++) {
        {
          String c = Character.valueOf((port[i]).charAt(j)).toString();
          String[] digitals = "0 1 2 3 4 5 6 7 8 9 :".split(" ");
          boolean judge = false;
          for (int k = 0; (k < ((List<String>)Conversions.doWrapArray(digitals)).size()); k++) {
            boolean _equals = c.equals(digitals[k]);
            if (_equals) {
              judge = true;
            }
          }
          if ((judge == false)) {
            this.warning("The port should be number", stmt, 
              DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT, DockerValidator.INVALID_PRIVATE_PORT);
          }
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkRunPortFormatStatementPort(final RunOption stmt) {
    String[] port = stmt.getPortName().split("[.]");
    if (((((List<String>)Conversions.doWrapArray(port)).size() != 4) || (((List<String>)Conversions.doWrapArray((port[3]).split("\\:"))).size() != 2))) {
      this.warning("The port format must be xx.xx.xx.xx:xx".toString(), stmt, 
        DockerPackage.Literals.RUN_OPTION__PORT_NAME, DockerValidator.INVALID_PRIVATE_PORT);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkRunPortNumberStatementPort(final RunOption stmt) {
    String[] port = stmt.getPortName().split("[.]");
    for (int i = 0; (i < ((List<String>)Conversions.doWrapArray(port)).size()); i++) {
      for (int j = 0; (j < (port[i]).length()); j++) {
        {
          String c = Character.valueOf((port[i]).charAt(j)).toString();
          String[] digitals = "0 1 2 3 4 5 6 7 8 9 :".split(" ");
          boolean judge = false;
          for (int k = 0; (k < ((List<String>)Conversions.doWrapArray(digitals)).size()); k++) {
            boolean _equals = c.equals(digitals[k]);
            if (_equals) {
              judge = true;
            }
          }
          if ((judge == false)) {
            this.warning("The port should be number", stmt, 
              DockerPackage.Literals.RUN_OPTION__PORT_NAME, DockerValidator.INVALID_PRIVATE_PORT);
          }
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkLogStatementTimeFormat(final LogOptions stmt) {
    String[] logtime = stmt.getTime().split("-");
    final String[] _converted_logtime = (String[])logtime;
    int _size = ((List<String>)Conversions.doWrapArray(_converted_logtime)).size();
    boolean _notEquals = (_size != 3);
    if (_notEquals) {
      this.warning("The time format must be xx-xx-xx".toString(), stmt, 
        DockerPackage.Literals.LOG_OPTIONS__TIME, DockerValidator.INVALID_SINCE_TIME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkLogStatementTimeNumberFormat1(final LogOptions stmt) {
    String[] logtime = stmt.getTime().split("-");
    for (int i = 0; (i < ((List<String>)Conversions.doWrapArray(logtime)).size()); i++) {
      for (int j = 0; (j < (logtime[i]).length()); j++) {
        {
          String c = Character.valueOf((logtime[i]).charAt(j)).toString();
          String[] digitals = "0 1 2 3 4 5 6 7 8 9".split(" ");
          boolean judge = false;
          for (int k = 0; (k < ((List<String>)Conversions.doWrapArray(digitals)).size()); k++) {
            boolean _equals = c.equals(digitals[k]);
            if (_equals) {
              judge = true;
            }
          }
          if ((judge == false)) {
            this.warning("The time should be number", stmt, 
              DockerPackage.Literals.LOG_OPTIONS__TIME, DockerValidator.INVALID_SINCE_TIME);
          }
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkLogStatementTimeNumberFormat2(final LogOptions stmt) {
    String[] logtime = stmt.getTime().split("-");
    String year_String_time = logtime[0];
    int year_int_time = Integer.parseInt(year_String_time);
    if (((year_int_time < 2019) && (year_int_time > 2022))) {
      this.warning("The time must be greater than 2019-01-01 and less than 2022", stmt, 
        DockerPackage.Literals.LOG_OPTIONS__TIME, DockerValidator.INVALID_SINCE_TIME);
    }
    String month_String_time = logtime[1];
    int month_int_time = Integer.parseInt(month_String_time);
    if (((month_int_time > 12) || (month_int_time < 1))) {
      this.warning("The time must be greater than 2019-01-01 and less than 2022", stmt, 
        DockerPackage.Literals.LOG_OPTIONS__TIME, DockerValidator.INVALID_SINCE_TIME);
    }
    String day_String_time = logtime[2];
    int day_int_time = Integer.parseInt(day_String_time);
    if (((day_int_time > 31) || (day_int_time < 1))) {
      this.warning("The time must be greater than 2019-01-01 and less than 2022", stmt, 
        DockerPackage.Literals.LOG_OPTIONS__TIME, DockerValidator.INVALID_SINCE_TIME);
    }
  }
}
