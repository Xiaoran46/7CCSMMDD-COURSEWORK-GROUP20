/*
 * generated by Xtext 2.24.0
 */
package uk.ac.kcl.inf.group20.docker.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.group20.docker.docker.AttachStatement;
import uk.ac.kcl.inf.group20.docker.docker.CommitOptions;
import uk.ac.kcl.inf.group20.docker.docker.CommitStatement;
import uk.ac.kcl.inf.group20.docker.docker.ContainerNameDeclaration;
import uk.ac.kcl.inf.group20.docker.docker.CpStatement;
import uk.ac.kcl.inf.group20.docker.docker.DiffStatement;
import uk.ac.kcl.inf.group20.docker.docker.DockerPackage;
import uk.ac.kcl.inf.group20.docker.docker.EventOptions;
import uk.ac.kcl.inf.group20.docker.docker.EventStatement;
import uk.ac.kcl.inf.group20.docker.docker.ExecStatement;
import uk.ac.kcl.inf.group20.docker.docker.ExportStatement;
import uk.ac.kcl.inf.group20.docker.docker.ImageOptions;
import uk.ac.kcl.inf.group20.docker.docker.ImageStatement;
import uk.ac.kcl.inf.group20.docker.docker.InspectOptions;
import uk.ac.kcl.inf.group20.docker.docker.InspectStatement;
import uk.ac.kcl.inf.group20.docker.docker.KillStatement;
import uk.ac.kcl.inf.group20.docker.docker.LogOptions;
import uk.ac.kcl.inf.group20.docker.docker.LogsStatement;
import uk.ac.kcl.inf.group20.docker.docker.Model;
import uk.ac.kcl.inf.group20.docker.docker.PauseStatement;
import uk.ac.kcl.inf.group20.docker.docker.PortStatement;
import uk.ac.kcl.inf.group20.docker.docker.PsOptions;
import uk.ac.kcl.inf.group20.docker.docker.PsStatement;
import uk.ac.kcl.inf.group20.docker.docker.RemoveImageStatement;
import uk.ac.kcl.inf.group20.docker.docker.RemoveStatement;
import uk.ac.kcl.inf.group20.docker.docker.RestartStatement;
import uk.ac.kcl.inf.group20.docker.docker.RunCreateStatement;
import uk.ac.kcl.inf.group20.docker.docker.RunOption;
import uk.ac.kcl.inf.group20.docker.docker.SourceOption;
import uk.ac.kcl.inf.group20.docker.docker.StartStatement;
import uk.ac.kcl.inf.group20.docker.docker.StopStatement;
import uk.ac.kcl.inf.group20.docker.docker.UnpauseStatement;
import uk.ac.kcl.inf.group20.docker.docker.WaitStatement;
import uk.ac.kcl.inf.group20.docker.services.DockerGrammarAccess;

@SuppressWarnings("all")
public class DockerSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DockerGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DockerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DockerPackage.ATTACH_STATEMENT:
				sequence_AttachStatement(context, (AttachStatement) semanticObject); 
				return; 
			case DockerPackage.COMMIT_OPTIONS:
				sequence_CommitOptions(context, (CommitOptions) semanticObject); 
				return; 
			case DockerPackage.COMMIT_STATEMENT:
				sequence_CommitStatement(context, (CommitStatement) semanticObject); 
				return; 
			case DockerPackage.CONTAINER_NAME_DECLARATION:
				sequence_ContainerNameDeclaration(context, (ContainerNameDeclaration) semanticObject); 
				return; 
			case DockerPackage.CP_STATEMENT:
				sequence_CpStatement(context, (CpStatement) semanticObject); 
				return; 
			case DockerPackage.DIFF_STATEMENT:
				sequence_DiffStatement(context, (DiffStatement) semanticObject); 
				return; 
			case DockerPackage.EVENT_OPTIONS:
				sequence_EventOptions(context, (EventOptions) semanticObject); 
				return; 
			case DockerPackage.EVENT_STATEMENT:
				sequence_EventStatement(context, (EventStatement) semanticObject); 
				return; 
			case DockerPackage.EXEC_STATEMENT:
				sequence_ExecStatement(context, (ExecStatement) semanticObject); 
				return; 
			case DockerPackage.EXPORT_STATEMENT:
				sequence_ExportStatement(context, (ExportStatement) semanticObject); 
				return; 
			case DockerPackage.IMAGE_OPTIONS:
				sequence_ImageOptions(context, (ImageOptions) semanticObject); 
				return; 
			case DockerPackage.IMAGE_STATEMENT:
				sequence_ImageStatement(context, (ImageStatement) semanticObject); 
				return; 
			case DockerPackage.INSPECT_OPTIONS:
				sequence_InspectOptions(context, (InspectOptions) semanticObject); 
				return; 
			case DockerPackage.INSPECT_STATEMENT:
				sequence_InspectStatement(context, (InspectStatement) semanticObject); 
				return; 
			case DockerPackage.KILL_STATEMENT:
				sequence_KillStatement(context, (KillStatement) semanticObject); 
				return; 
			case DockerPackage.LOG_OPTIONS:
				sequence_LogOptions(context, (LogOptions) semanticObject); 
				return; 
			case DockerPackage.LOGS_STATEMENT:
				sequence_LogsStatement(context, (LogsStatement) semanticObject); 
				return; 
			case DockerPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DockerPackage.PAUSE_STATEMENT:
				sequence_PauseStatement(context, (PauseStatement) semanticObject); 
				return; 
			case DockerPackage.PORT_STATEMENT:
				sequence_PortStatement(context, (PortStatement) semanticObject); 
				return; 
			case DockerPackage.PS_OPTIONS:
				sequence_PsOptions(context, (PsOptions) semanticObject); 
				return; 
			case DockerPackage.PS_STATEMENT:
				sequence_PsStatement(context, (PsStatement) semanticObject); 
				return; 
			case DockerPackage.REMOVE_IMAGE_STATEMENT:
				sequence_RemoveImageStatement(context, (RemoveImageStatement) semanticObject); 
				return; 
			case DockerPackage.REMOVE_STATEMENT:
				sequence_RemoveStatement(context, (RemoveStatement) semanticObject); 
				return; 
			case DockerPackage.RESTART_STATEMENT:
				sequence_RestartStatement(context, (RestartStatement) semanticObject); 
				return; 
			case DockerPackage.RUN_CREATE_STATEMENT:
				sequence_RunCreateStatement(context, (RunCreateStatement) semanticObject); 
				return; 
			case DockerPackage.RUN_OPTION:
				sequence_RunOption(context, (RunOption) semanticObject); 
				return; 
			case DockerPackage.SOURCE_OPTION:
				sequence_SourceOption(context, (SourceOption) semanticObject); 
				return; 
			case DockerPackage.START_STATEMENT:
				sequence_StartStatement(context, (StartStatement) semanticObject); 
				return; 
			case DockerPackage.STOP_STATEMENT:
				sequence_StopStatement(context, (StopStatement) semanticObject); 
				return; 
			case DockerPackage.UNPAUSE_STATEMENT:
				sequence_UnpauseStatement(context, (UnpauseStatement) semanticObject); 
				return; 
			case DockerPackage.WAIT_STATEMENT:
				sequence_WaitStatement(context, (WaitStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statements returns AttachStatement
	 *     AttachStatement returns AttachStatement
	 *
	 * Constraint:
	 *     (attachOption=AttachOption containerName=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_AttachStatement(ISerializationContext context, AttachStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.ATTACH_STATEMENT__ATTACH_OPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.ATTACH_STATEMENT__ATTACH_OPTION));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.ATTACH_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.ATTACH_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttachStatementAccess().getAttachOptionAttachOptionEnumRuleCall_1_0(), semanticObject.getAttachOption());
		feeder.accept(grammarAccess.getAttachStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_2_0_1(), semanticObject.eGet(DockerPackage.Literals.ATTACH_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CommitOptions returns CommitOptions
	 *
	 * Constraint:
	 *     ((option='author' author=STRING) | option='create' | (option='commit_description' description=STRING) | option='pause_when_commit')
	 */
	protected void sequence_CommitOptions(ISerializationContext context, CommitOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns CommitStatement
	 *     CommitStatement returns CommitStatement
	 *
	 * Constraint:
	 *     (commitOptions+=CommitOptions* containerName=[ContainerNameDeclaration|ID] repository=STRING)
	 */
	protected void sequence_CommitStatement(ISerializationContext context, CommitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns ContainerNameDeclaration
	 *     ContainerNameDeclaration returns ContainerNameDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ContainerNameDeclaration(ISerializationContext context, ContainerNameDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.CONTAINER_NAME_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.CONTAINER_NAME_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainerNameDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns CpStatement
	 *     CpStatement returns CpStatement
	 *
	 * Constraint:
	 *     (link=LinkOption source=SourceOption destination=STRING)
	 */
	protected void sequence_CpStatement(ISerializationContext context, CpStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.CP_STATEMENT__LINK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.CP_STATEMENT__LINK));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.CP_STATEMENT__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.CP_STATEMENT__SOURCE));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.CP_STATEMENT__DESTINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.CP_STATEMENT__DESTINATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCpStatementAccess().getLinkLinkOptionEnumRuleCall_1_0(), semanticObject.getLink());
		feeder.accept(grammarAccess.getCpStatementAccess().getSourceSourceOptionParserRuleCall_2_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getCpStatementAccess().getDestinationSTRINGTerminalRuleCall_3_0(), semanticObject.getDestination());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns DiffStatement
	 *     DiffStatement returns DiffStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_DiffStatement(ISerializationContext context, DiffStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.DIFF_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.DIFF_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiffStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.DIFF_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventOptions returns EventOptions
	 *
	 * Constraint:
	 *     ((option='filter' commands=STRING) | (option='since' timeS=STRING) | (option='until' timeU=STRING))
	 */
	protected void sequence_EventOptions(ISerializationContext context, EventOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns EventStatement
	 *     EventStatement returns EventStatement
	 *
	 * Constraint:
	 *     eventOptions+=EventOptions+
	 */
	protected void sequence_EventStatement(ISerializationContext context, EventStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns ExecStatement
	 *     ExecStatement returns ExecStatement
	 *
	 * Constraint:
	 *     (execOptions+=ExecOption* containerName=[ContainerNameDeclaration|ID] commands=STRING)
	 */
	protected void sequence_ExecStatement(ISerializationContext context, ExecStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns ExportStatement
	 *     ExportStatement returns ExportStatement
	 *
	 * Constraint:
	 *     (file_path=STRING containerName=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_ExportStatement(ISerializationContext context, ExportStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.EXPORT_STATEMENT__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.EXPORT_STATEMENT__FILE_PATH));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.EXPORT_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.EXPORT_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportStatementAccess().getFile_pathSTRINGTerminalRuleCall_1_0(), semanticObject.getFile_path());
		feeder.accept(grammarAccess.getExportStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_2_0_1(), semanticObject.eGet(DockerPackage.Literals.EXPORT_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImageOptions returns ImageOptions
	 *
	 * Constraint:
	 *     (
	 *         option='show_all' | 
	 *         option='show_digests' | 
	 *         (option='filter' condition=STRING) | 
	 *         (option='format' formats=STRING) | 
	 *         option='complete' | 
	 *         option='show_ID'
	 *     )
	 */
	protected void sequence_ImageOptions(ISerializationContext context, ImageOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns ImageStatement
	 *     ImageStatement returns ImageStatement
	 *
	 * Constraint:
	 *     (imageOptions+=ImageOptions* repository=STRING)
	 */
	protected void sequence_ImageStatement(ISerializationContext context, ImageStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InspectOptions returns InspectOptions
	 *
	 * Constraint:
	 *     ((option='format' formats=STRING) | option='show_size' | (option='type' types=STRING))
	 */
	protected void sequence_InspectOptions(ISerializationContext context, InspectOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns InspectStatement
	 *     InspectStatement returns InspectStatement
	 *
	 * Constraint:
	 *     inspectOptions+=InspectOptions+
	 */
	protected void sequence_InspectStatement(ISerializationContext context, InspectStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns KillStatement
	 *     KillStatement returns KillStatement
	 *
	 * Constraint:
	 *     (kill=KillOption containerName=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_KillStatement(ISerializationContext context, KillStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.KILL_STATEMENT__KILL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.KILL_STATEMENT__KILL));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.KILL_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.KILL_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKillStatementAccess().getKillKillOptionEnumRuleCall_0_0(), semanticObject.getKill());
		feeder.accept(grammarAccess.getKillStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.KILL_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogOptions returns LogOptions
	 *
	 * Constraint:
	 *     (option='track_output' | (option='since' time=STRING) | option='show_timestamp' | (option='show_tail_n_logs' number=INT))
	 */
	protected void sequence_LogOptions(ISerializationContext context, LogOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns LogsStatement
	 *     LogsStatement returns LogsStatement
	 *
	 * Constraint:
	 *     (logOptions+=LogOptions* containerName=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_LogsStatement(ISerializationContext context, LogsStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     statements+=Statements+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns PauseStatement
	 *     PauseStatement returns PauseStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_PauseStatement(ISerializationContext context, PauseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPauseStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.PAUSE_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns PortStatement
	 *     PortStatement returns PortStatement
	 *
	 * Constraint:
	 *     (containerName=[ContainerNameDeclaration|ID] private_port=STRING)
	 */
	protected void sequence_PortStatement(ISerializationContext context, PortStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.PORT_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.PORT_STATEMENT__CONTAINER_NAME));
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.PORT_STATEMENT__PRIVATE_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.PORT_STATEMENT__CONTAINER_NAME, false));
		feeder.accept(grammarAccess.getPortStatementAccess().getPrivate_portSTRINGTerminalRuleCall_2_0(), semanticObject.getPrivate_port());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PsOptions returns PsOptions
	 *
	 * Constraint:
	 *     (
	 *         option='show_container' | 
	 *         option='show_all_containers' | 
	 *         (option='filter' commands=STRING) | 
	 *         (option='format' formats=STRING) | 
	 *         option='show_last_container' | 
	 *         (option='list_last_n_containers' n=INT) | 
	 *         option='complete' | 
	 *         option='only_show_id' | 
	 *         option='show_size'
	 *     )
	 */
	protected void sequence_PsOptions(ISerializationContext context, PsOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns PsStatement
	 *     PsStatement returns PsStatement
	 *
	 * Constraint:
	 *     psOptions+=PsOptions+
	 */
	protected void sequence_PsStatement(ISerializationContext context, PsStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns RemoveImageStatement
	 *     RemoveImageStatement returns RemoveImageStatement
	 *
	 * Constraint:
	 *     (removeimageOptions+=RemoveImageOptions* image=STRING)
	 */
	protected void sequence_RemoveImageStatement(ISerializationContext context, RemoveImageStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns RemoveStatement
	 *     RemoveStatement returns RemoveStatement
	 *
	 * Constraint:
	 *     (rmOptions=RmOptions? containerName=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_RemoveStatement(ISerializationContext context, RemoveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns RestartStatement
	 *     RestartStatement returns RestartStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_RestartStatement(ISerializationContext context, RestartStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRestartStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.RESTART_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns RunCreateStatement
	 *     RunCreateStatement returns RunCreateStatement
	 *
	 * Constraint:
	 *     (order=RunorCreate runOptions+=RunOption* image=Image commands=STRING)
	 */
	protected void sequence_RunCreateStatement(ISerializationContext context, RunCreateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RunOption returns RunOption
	 *
	 * Constraint:
	 *     (
	 *         (condition='standard' outType=OutType) | 
	 *         condition='backstage' | 
	 *         condition='interface' | 
	 *         condition='random_port' | 
	 *         (condition='specify_port' portName=STRING) | 
	 *         condition='terminate' | 
	 *         (condition='DNS' server=STRING) | 
	 *         (condition='search_DNS' domainName=STRING) | 
	 *         (condition='hostname' hostname=STRING) | 
	 *         (condition='environment' environmentVariable=STRING setEnvironmentVariable=STRING) | 
	 *         (condition='network' connectType=STRING) | 
	 *         (condition='name' containerName=[ContainerNameDeclaration|ID])
	 *     )
	 */
	protected void sequence_RunOption(ISerializationContext context, RunOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SourceOption returns SourceOption
	 *
	 * Constraint:
	 *     (option1=STRING | option2=[ContainerNameDeclaration|ID])
	 */
	protected void sequence_SourceOption(ISerializationContext context, SourceOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns StartStatement
	 *     StartStatement returns StartStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_StartStatement(ISerializationContext context, StartStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.START_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.START_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.START_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns StopStatement
	 *     StopStatement returns StopStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_StopStatement(ISerializationContext context, StopStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStopStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.STOP_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns UnpauseStatement
	 *     UnpauseStatement returns UnpauseStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_UnpauseStatement(ISerializationContext context, UnpauseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnpauseStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.UNPAUSE_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statements returns WaitStatement
	 *     WaitStatement returns WaitStatement
	 *
	 * Constraint:
	 *     containerName=[ContainerNameDeclaration|ID]
	 */
	protected void sequence_WaitStatement(ISerializationContext context, WaitStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerPackage.Literals.WAIT_STATEMENT__CONTAINER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerPackage.Literals.WAIT_STATEMENT__CONTAINER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitStatementAccess().getContainerNameContainerNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DockerPackage.Literals.WAIT_STATEMENT__CONTAINER_NAME, false));
		feeder.finish();
	}
	
	
}
